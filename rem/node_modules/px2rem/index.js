var fs = require('fs');
var path = require('path');
var css = require('css');
var nUnitPx = 100;
var nTfx = Math.max(2, nUnitPx.toString().length - 1);
var _cfg = {
  ingore: 'px'
, inputDir: 'css'
, outputDir: 'output'
, nUnitPx: nUnitPx
, nTfx: nTfx
};

var px2rem = function() {};

px2rem._cvt = function(filepath) {
  if(!filepath || !/\.(css)$/.test(filepath)) {
    console.error('fail to covert file which path looks like: ' + filepath);
    return;
  }
  var realpath = _cfg['inputDir'] + '/' + filepath;
  var data = fs.readFileSync(realpath, 'utf-8');
  var ast = css.parse(data);
  var aCssRules = ast.stylesheet.rules;
  for (i = 0; i < aCssRules.length; i++) {
  var oCss = aCssRules[i];
  if ('rule' == oCss.type) {
    var declarations = oCss['declarations'];
    for (var j = 0; j < declarations.length; j++) {
      var oDeclaration = declarations[j];
      if ('declaration' == oDeclaration['type']) {
        var orival = oDeclaration['value'];
        var remval = value = oDeclaration['value'].replace(/\b(\d+(\.\d+)?)px\b/ig, function(m, p){
          var num = p / _cfg['nUnitPx'];
          num = num.toString().split('.').length > 1 && num.toString().split('.')[1].length > 2 ?  num.toFixed(_cfg['nTfx']) : num;
          return num + 'rem';
        });
        var bFlag = typeof declarations[j+1] != 'undefined' && 'comment' == declarations[j+1]['type'] && _cfg['ingore'] == declarations[j+1]['comment'].trim();
        var value = bFlag ? orival : remval;
        bFlag && declarations.splice(j + 1, 1);
        ast.stylesheet.rules[i]['declarations'][j]['value'] = value;
      }
    }
  }
}
  var ret = css.stringify(ast, {sourcemap: true}).code;
  var outpath = _cfg['outputDir'] + '/' + filepath;
  fs.writeFile(outpath, ret);
}

px2rem.convert = function(opt) {
  var opt = opt || {};
  _cfg['nUnitPx'] = opt.unitPx || 100;
  _cfg['nTfx'] = Math.max(2, _cfg['nUnitPx'].toString().length - 1);
  var dir = opt.dir || 'css';
  var dirname = __dirname + '/../..';
  dir = dir.slice(0, 1) == '/' ? dir.substr(1) : dir;
  _cfg['inputDir'] = dirname + '/' + dir;
  // 判断输出文件夹是否存在 不存在则创建
  var outdir = dirname + '/' + _cfg['outputDir'];
  var bExist = fs.existsSync(outdir);
  !bExist && fs.mkdir(outdir);
  _cfg['outputDir'] = outdir;
  // 遍历文件夹下所有的文件
  var files = fs.readdirSync(_cfg['inputDir']);
  for (var i = 0; i < files.length; i++) {
    var filepath = files[i];
    if(filepath || !/\.(css)$/.test(filepath)) {
      this._cvt(filepath);
    }
  }
}
module.exports = px2rem;